{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/20200606/","result":{"data":{"site":{"siteMetadata":{"disqusShortname":"","subtitle":"web系の技術について紹介します","title":"kon-shou's blog","url":"https://blog.kon-shou.com"}},"markdownRemark":{"id":"978dac77-37f5-5ea2-9b94-b6d8d49d08a4","html":"<h1 id=\"はじめに\" style=\"position:relative;\"><a href=\"#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB\" aria-label=\"はじめに permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>はじめに</h1>\n<p><a href=\"https://ohbarye.hatenablog.jp/entry/2018/08/20/233203\">“まともなステージング環境”を考える</a> という記事を読んで、文中の</p>\n<blockquote>\n<p>開発者、非開発者がある機能のレビューをしたい</p>\n</blockquote>\n<blockquote>\n<p>・本番相当のデータ＋各開発者の feature branch のアプリケーションが動作する環境</p>\n</blockquote>\n<blockquote>\n<p>・弊社では Staging 環境と呼んでいる…が正確ではなく、Feature Staging などと呼んだ方が良さそうだ</p>\n</blockquote>\n<p>という環境を半年ほど前に準備したことを思い出したので、その振り返りをする。</p>\n<h1 id=\"作った環境について\" style=\"position:relative;\"><a href=\"#%E4%BD%9C%E3%81%A3%E3%81%9F%E7%92%B0%E5%A2%83%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\" aria-label=\"作った環境について permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>作った環境について</h1>\n<p>もともと非開発者が問い合わせ対応だったり、開発者がデバックに使う環境があった。</p>\n<p>それに加えて「非開発者が、仕様や開発進捗の確認のために、任意のブランチを、任意のタイミングで、Slack経由でデプロイしたい」という要望があったので、その環境を準備した。</p>\n<p>（上記のブログ記事で言う「Feature Staging環境」にあたるはず。たぶん。）</p>\n<p>Feature Staging環境の作成前は、ローカル環境で上記の要望は実現していたが、</p>\n<ul>\n<li>非開発者にとってローカルで動かすのは負担が高い</li>\n<li>非開発者のPCではスペック的に厳しい</li>\n</ul>\n<p>といった理由で、Feature Staging環境の需要があったため、その環境を準備した。</p>\n<h1 id=\"feature-staging環境の使い方\" style=\"position:relative;\"><a href=\"#feature-staging%E7%92%B0%E5%A2%83%E3%81%AE%E4%BD%BF%E3%81%84%E6%96%B9\" aria-label=\"feature staging環境の使い方 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Feature Staging環境の使い方</h1>\n<p>Slackで <code class=\"language-text\">@aws lambda invoke --function-name xxx --payload {&quot;branch&quot;: &quot;feature/xxx&quot;}</code> という感じでコマンド実行すると、５分後くらいに「 <code class=\"language-text\">http://feature_xxx.example.com/</code> にデプロイしました」と返事があるという感じ。</p>\n<p>システム的な流れでいうと下記のような感じ。</p>\n<ol>\n<li>featureブランチはCIで、DockerImageがビルドされ <code class=\"language-text\">AWS ECR</code> にプッシュ</li>\n<li>Slackから <code class=\"language-text\">AWS Chatbot</code> を使って、ブランチ名を引数として <code class=\"language-text\">AWS Lambda</code> を起動</li>\n<li><code class=\"language-text\">AWS Lambda</code> は <code class=\"language-text\">AWS ECS</code> に、指定されたブランチでコンテナを起動</li>\n<li><code class=\"language-text\">AWS Route53</code> で起動したコンテナと、ブランチ名から作成されたURL (例： <code class=\"language-text\">http://feature_xxx.example.com</code> ) を紐付ける</li>\n</ol>\n<p>技術的な詳細については <a href=\"https://qiita.com/kon_shou/items/70cc47dc76ba734aefdc\">Qiitaの記事</a> を参照。</p>\n<p>（Slackの部分は無いけど）</p>\n<h1 id=\"工夫したところ\" style=\"position:relative;\"><a href=\"#%E5%B7%A5%E5%A4%AB%E3%81%97%E3%81%9F%E3%81%A8%E3%81%93%E3%82%8D\" aria-label=\"工夫したところ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>工夫したところ</h1>\n<h3 id=\"タスク定義を書くの辛い-→-書かない\" style=\"position:relative;\"><a href=\"#%E3%82%BF%E3%82%B9%E3%82%AF%E5%AE%9A%E7%BE%A9%E3%82%92%E6%9B%B8%E3%81%8F%E3%81%AE%E8%BE%9B%E3%81%84-%E2%86%92-%E6%9B%B8%E3%81%8B%E3%81%AA%E3%81%84\" aria-label=\"タスク定義を書くの辛い → 書かない permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>タスク定義を書くの辛い → 書かない</h3>\n<p><a href=\"https://docs.aws.amazon.com/ja_jp/AmazonECS/latest/developerguide/ECS_CLI.html\">ecs-cli</a> を使って、既存のローカル開発用の <code class=\"language-text\">docker-compose.yml</code> を流用。</p>\n<p>これを使えば、ローカル開発用の <code class=\"language-text\">docker-compose.yml</code> だけで、ECS上にコンテナ乱立！楽勝！となる、はずだった…（後述）</p>\n<p>ただ「開発初期はECSタスク定義に触らなくて速度上がる」というのは間違ってないはず。</p>\n<p>結局ECSタスク定義は書いてないし、あんまり書きたくなかったので、そのメリットは大きい。はず。</p>\n<h3 id=\"ecsでmysqlコンテナ繋げない-→-繋げた\" style=\"position:relative;\"><a href=\"#ecs%E3%81%A7mysql%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E7%B9%8B%E3%81%92%E3%81%AA%E3%81%84-%E2%86%92-%E7%B9%8B%E3%81%92%E3%81%9F\" aria-label=\"ecsでmysqlコンテナ繋げない → 繋げた permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ECSでMySQLコンテナ繋げない → 繋げた</h3>\n<p>docker-compose では、サービスとして app と mysql があるとして、app から mysql へ繋ぐ際には mysql でつなげるけど、ECSでは 127.0.0.1 とかで繋がないといけない。</p>\n<p>（ただ、実際の運用ではあらかじめRDSを立てといて、そこにアクセスするようになったから、あんまり意味なかった）</p>\n<h3 id=\"entrypointのプロセスから生やした子プロセスで、aws-cliを通したs3データの取得が失敗する-→-成功した\" style=\"position:relative;\"><a href=\"#entrypoint%E3%81%AE%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9%E3%81%8B%E3%82%89%E7%94%9F%E3%82%84%E3%81%97%E3%81%9F%E5%AD%90%E3%83%97%E3%83%AD%E3%82%BB%E3%82%B9%E3%81%A7%E3%80%81aws-cli%E3%82%92%E9%80%9A%E3%81%97%E3%81%9Fs3%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E5%8F%96%E5%BE%97%E3%81%8C%E5%A4%B1%E6%95%97%E3%81%99%E3%82%8B-%E2%86%92-%E6%88%90%E5%8A%9F%E3%81%97%E3%81%9F\" aria-label=\"entrypointのプロセスから生やした子プロセスで、aws cliを通したs3データの取得が失敗する → 成功した permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>entrypointのプロセスから生やした子プロセスで、AWS CLIを通したS3データの取得が失敗する → 成功した</h3>\n<p>aws cli を叩いてるところが、なぜか「アクセス拒否」となり動かない！という問題があったが、答えは下記。</p>\n<p><a href=\"https://aws.amazon.com/jp/premiumsupport/knowledge-center/ecs-iam-task-roles-config-errors/\">https://aws.amazon.com/jp/premiumsupport/knowledge-center/ecs-iam-task-roles-config-errors/</a></p>\n<blockquote>\n<p>環境変数 AWS<em>CONTAINER</em>CREDENTIALS<em>RELATIVE</em>URI を使用できるのは、コンテナ内の PID 1 プロセスのみです。コンテナで複数のプロセスまたは init プロセス (ラッパースクリプト、start スクリプト、supervisord など) を実行している場合、この環境変数を非 PID 1 プロセスで使用することはできません。</p>\n</blockquote>\n<p>今回は entrypoint のプロセスから service で php-fpm のプロセスを生やしていたので、そこからクレデンシャルが読めなかった。</p>\n<p>コンテナ運用の思想として「プロセスごとにコンテナ分ける」「プロセスが落ちたら、コンテナ再起動するので service 使わない」みたいなことが多分あって、そういう「正しい」使い方をしてると嵌まらないポイントだと思う。</p>\n<p>おかげでネットで解決策が見つからなくて大変だった。</p>\n<h3 id=\"お高い-→-ちょっとお安く\" style=\"position:relative;\"><a href=\"#%E3%81%8A%E9%AB%98%E3%81%84-%E2%86%92-%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E3%81%8A%E5%AE%89%E3%81%8F\" aria-label=\"お高い → ちょっとお安く permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>お高い → ちょっとお安く</h3>\n<p>Fargate Spotで、お安くなったはず。</p>\n<blockquote>\n<p>Fargate価格から最大70%割引で提供します。</p>\n</blockquote>\n<p><a href=\"https://aws.amazon.com/jp/blogs/news/aws-fargate-spot-now-generally-available/\">https://aws.amazon.com/jp/blogs/news/aws-fargate-spot-now-generally-available/</a></p>\n<h1 id=\"工夫したかったけど、どうにもならなかったところ\" style=\"position:relative;\"><a href=\"#%E5%B7%A5%E5%A4%AB%E3%81%97%E3%81%9F%E3%81%8B%E3%81%A3%E3%81%9F%E3%81%91%E3%81%A9%E3%80%81%E3%81%A9%E3%81%86%E3%81%AB%E3%82%82%E3%81%AA%E3%82%89%E3%81%AA%E3%81%8B%E3%81%A3%E3%81%9F%E3%81%A8%E3%81%93%E3%82%8D\" aria-label=\"工夫したかったけど、どうにもならなかったところ permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>工夫したかったけど、どうにもならなかったところ</h1>\n<h3 id=\"デプロイフローのシステムの流れが複雑\" style=\"position:relative;\"><a href=\"#%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E3%83%95%E3%83%AD%E3%83%BC%E3%81%AE%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%81%AE%E6%B5%81%E3%82%8C%E3%81%8C%E8%A4%87%E9%9B%91\" aria-label=\"デプロイフローのシステムの流れが複雑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>デプロイフローのシステムの流れが複雑</h3>\n<p>実は使い方の 「3. <code class=\"language-text\">AWS Lambda</code> は <code class=\"language-text\">AWS ECS</code> に、指定されたブランチでコンテナを起動」という部分はもっと複雑で</p>\n<ol>\n<li>既存でECSタスクが存在してたら削除</li>\n<li>ECSタスクを起動</li>\n<li>Aレコードを作成</li>\n<li>ECSタスクとAレコードを紐付け</li>\n</ol>\n<p>という処理をシェルスクリプト( <code class=\"language-text\">deploy.sh</code> )に書いて</p>\n<ol>\n<li><code class=\"language-text\">deploy.sh</code> を立ち上げ時に実行する <code class=\"language-text\">docker-compose.yml</code> を準備する</li>\n<li>それを <code class=\"language-text\">ecs-cli</code> を使って「デプロイ用のECSタスク」としてアップロードする</li>\n<li><code class=\"language-text\">AWS Chatbot</code> は、その「デプロイ用のECSタスク」を起動するための <code class=\"language-text\">AWS Lambda</code> を起動</li>\n<li>「デプロイ用のECSタスク」は、起動処理として <code class=\"language-text\">deploy.sh</code> を実行</li>\n<li><code class=\"language-text\">deploy.sh</code> の結果「指定したブランチのコンテナ」と「URL」が生成</li>\n</ol>\n<p>という、わりかし意味不明なフローになっている。</p>\n<p>「いや <code class=\"language-text\">deploy-ecs.sh</code> なんて作らんと、直接 node でデプロイのコードを書いて、それをLamdaとして上げれば良いんじゃないの？」という話になるけど、実は <code class=\"language-text\">deploy-ecs.sh</code> に <code class=\"language-text\">ecs-cli</code> を利用してて、 <code class=\"language-text\">ecs-cli</code> にSDKが無いという事情がある。</p>\n<p><code class=\"language-text\">ecs-cli</code> のおかげで、ECSのタスク定義を書かなくて良くて楽だと思ったら、デプロイフローが難しくなって結果トントンというオチだ。</p>\n<p>ちなみにLambda の Custome Runtime を上手く使えば <code class=\"language-text\">deploy.sh</code> をLambdaとして使えるとは思ったけど、正直よく分かんなかった。</p>\n<p>デフォルトでサポートして欲しい。</p>\n<h3 id=\"「小回りがきかない」のが面倒くさい\" style=\"position:relative;\"><a href=\"#%E3%80%8C%E5%B0%8F%E5%9B%9E%E3%82%8A%E3%81%8C%E3%81%8D%E3%81%8B%E3%81%AA%E3%81%84%E3%80%8D%E3%81%AE%E3%81%8C%E9%9D%A2%E5%80%92%E3%81%8F%E3%81%95%E3%81%84\" aria-label=\"「小回りがきかない」のが面倒くさい permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>「小回りがきかない」のが面倒くさい</h3>\n<p>dockerにおいて「ステートレス」というのは重要なキーワードである。</p>\n<p>状態を持たないからこそ、スケールアウト/インの柔軟性があったり、ソフトのチューニングといった「差別化に繋がらない重労働」をなくすことができる。</p>\n<p>ただそれがかえって「ステートフル」に比べ回り道を強いられることがあって、それが辛みにつながることがある。</p>\n<p>例えば「CIでDockerImageをビルドして、それをECRにプッシュして、Slackからそれをデプロイする」という今回の仕様は「ソースコードの変更をリアルタイムに反映したい」という場合に、回り道に感じられる。</p>\n<p>壁パスが発生する時点で待ち時間が増えるし、そもそもこのフローを理解するのにも手間がかかる。</p>\n<p>じゃあいっそステートフルに倒して「常にコンテナ立ち上げっぱなしで、都度git pull してきて、ビルドすれば良くない？」という話になる。</p>\n<p>ここで大事なのは、やりたいことが「ステートレス」か「ステートフル」なのか見極めて適切なツールを選ぶ、ということだ。</p>\n<p>コンテナはそういう「ある種面倒くさいものだ」と認識して、それが許容できない場合にはEC2とかを使うというのも一つの手だ。</p>\n<p>脇道にそれたけど、この「小回りがきかない」という問題の解決策としては「すみません、以前みたいにローカル環境でお願いします」と言うしか無い気がしてる。</p>\n<h1 id=\"feature-stagingを作ったことへの個人的な感想\" style=\"position:relative;\"><a href=\"#feature-staging%E3%82%92%E4%BD%9C%E3%81%A3%E3%81%9F%E3%81%93%E3%81%A8%E3%81%B8%E3%81%AE%E5%80%8B%E4%BA%BA%E7%9A%84%E3%81%AA%E6%84%9F%E6%83%B3\" aria-label=\"feature stagingを作ったことへの個人的な感想 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Feature Stagingを作ったことへの個人的な感想</h1>\n<ul>\n<li>このレベルのインフラを弄るのは、ぶっちゃけ「万が一デグレしたら…！」という心理的な覚悟も必要無いし、レゴブロック弄るみたいで楽しかった。</li>\n<li>「コンテナによるインフラ」ってどのくらい流行ってるだろ？コンテナが、例えばEC2に比べ明らかな上位互換かと言われたら、そんなこと無いはず。メリデメ考えたら、コンテナ一色って未来は無いんじゃないかな〜。</li>\n</ul>","fields":{"slug":"/posts/20200606/","tagSlugs":["/tag/aws/","/tag/ecs/"]},"frontmatter":{"date":"2020-06-06","tags":["AWS","ECS"],"title":"Feature Staging 環境を作ったことの振り返り","description":"ブランチごとに動作確認できる環境を作ったことの振り返りです。","image":null}}},"pageContext":{"slug":"/posts/20200606/"}},"staticQueryHashes":["1155056556","1525128060","783282510"]}